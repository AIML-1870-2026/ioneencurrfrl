<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Enchanted Sprint</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #000; display: flex; justify-content: center; align-items: center; min-height: 100vh; overflow: hidden; }
canvas { display: block; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>'use strict';

// â”€â”€ CANVAS SETUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = 800, H = 400;
const DPR = Math.min(window.devicePixelRatio || 1, 3);
canvas.width = W * DPR; canvas.height = H * DPR;
function resize() {
  const s = Math.min(window.innerWidth / W, window.innerHeight / H);
  canvas.style.width = s * W + 'px'; canvas.style.height = s * H + 'px';
}
resize(); window.addEventListener('resize', resize);

// â”€â”€ ROUNDRECT POLYFILL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r) {
    r = Math.min(r, w/2, h/2);
    this.moveTo(x+r,y); this.lineTo(x+w-r,y);
    this.quadraticCurveTo(x+w,y,x+w,y+r);
    this.lineTo(x+w,y+h-r); this.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
    this.lineTo(x+r,y+h); this.quadraticCurveTo(x,y+h,x,y+h-r);
    this.lineTo(x,y+r); this.quadraticCurveTo(x,y,x+r,y);
    this.closePath(); return this;
  };
}

// â”€â”€ CONSTANTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const GY = 318;          // ground y (feet)
const PX = 120;          // player x
const BPM = 120;
const BEAT = 500;        // ms per beat

// â”€â”€ AUDIO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let AC = null;
function ensureAudio() {
  if (!AC) AC = new (window.AudioContext || window.webkitAudioContext)();
  if (AC.state === 'suspended') AC.resume();
}
function tone(freq, dur, type='sine', vol=0.25, delay=0) {
  if (!AC) return;
  const o = AC.createOscillator(), g = AC.createGain();
  o.connect(g); g.connect(AC.destination);
  o.type = type; o.frequency.value = freq;
  const t = AC.currentTime + delay;
  g.gain.setValueAtTime(0.001, t);
  g.gain.linearRampToValueAtTime(vol, t + 0.01);
  g.gain.exponentialRampToValueAtTime(0.001, t + dur);
  o.start(t); o.stop(t + dur + 0.05);
}
function chord(freqs, dur, type='sine', vol=0.18) { freqs.forEach(f => tone(f, dur, type, vol)); }
const SFX = {
  jumpShort() { tone(660, 0.12, 'triangle', 0.28); },
  jumpFull()  { tone(500,0.08,'triangle',0.3); tone(700,0.12,'triangle',0.25,0.06); tone(900,0.15,'triangle',0.2,0.12); },
  land()      { tone(130, 0.09, 'sawtooth', 0.2); },
  death()     { tone(440,0.1,'sawtooth',0.4); tone(330,0.15,'sawtooth',0.35,0.1); tone(220,0.3,'sawtooth',0.3,0.25); },
  onBeat()    { tone(1047,0.08,'sine',0.35); tone(1319,0.06,'sine',0.25,0.04); },
  nearMiss()  { if(!AC)return; const o=AC.createOscillator(),g=AC.createGain(); o.connect(g); g.connect(AC.destination); o.frequency.setValueAtTime(900,AC.currentTime); o.frequency.linearRampToValueAtTime(200,AC.currentTime+0.18); g.gain.setValueAtTime(0.2,AC.currentTime); g.gain.exponentialRampToValueAtTime(0.001,AC.currentTime+0.2); o.start(); o.stop(AC.currentTime+0.22); },
  combo(n)    { for(let i=0;i<4;i++) tone(440*(1+n*0.15)*(1+i*0.25),0.1,'triangle',0.2,i*0.07); },
  bossIn()    { chord([110,147,175],0.8,'sawtooth',0.28); tone(55,0.5,'sawtooth',0.35,0.1); },
  bossOut()   { [523,659,784,1047].forEach((f,i)=>tone(f,0.2,'triangle',0.3,i*0.12)); },
  fairy()     { tone(1600,0.05,'sine',0.18); tone(2100,0.05,'sine',0.14,0.06); tone(1600,0.04,'sine',0.1,0.12); },
  beat()      { tone(80, 0.04, 'sine', 0.12); },
};

// â”€â”€ PARTICLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const parts = [];
function spawnParts(x, y, n, {color='#f9c784', spread=4, life=40, grav=0.15, sz=3, angle, aSpread=Math.PI*2}={}) {
  for (let i=0; i<n; i++) {
    const a = angle !== undefined ? angle + (Math.random()-0.5)*aSpread : Math.random()*Math.PI*2;
    const spd = spread*(0.4+Math.random()*0.8);
    parts.push({ x, y, vx:Math.cos(a)*spd, vy:Math.sin(a)*spd, life, maxLife:life, color, sz:sz*(0.5+Math.random()*0.6), grav });
  }
}
function updateParts() {
  for (let i=parts.length-1; i>=0; i--) {
    const p=parts[i]; p.x+=p.vx; p.y+=p.vy; p.vy+=p.grav; p.life--;
    if (p.life<=0) parts.splice(i,1);
  }
}
function drawParts() {
  parts.forEach(p => {
    ctx.globalAlpha = p.life/p.maxLife;
    ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.sz,0,Math.PI*2); ctx.fill();
  });
  ctx.globalAlpha = 1;
}

// â”€â”€ FLOAT TEXT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const floats = [];
function spawnFloat(text, x, y, color='#f9c784') { floats.push({text,x,y,life:55,color}); }
function updateFloats() { for(let i=floats.length-1;i>=0;i--){ floats[i].y-=0.8; if(--floats[i].life<=0) floats.splice(i,1); } }
function drawFloats() {
  ctx.font = "bold 14px 'Georgia', serif"; ctx.textAlign = 'center';
  floats.forEach(f => {
    const a=f.life/55;
    ctx.globalAlpha=a*0.5; ctx.fillStyle='#000';
    ctx.fillText(f.text,f.x+1,f.y+1);
    ctx.globalAlpha=a; ctx.fillStyle=f.color;
    ctx.fillText(f.text,f.x,f.y);
  });
  ctx.globalAlpha=1; ctx.textAlign='left';
}

// â”€â”€ SCREEN SHAKE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let shakeF=0, shakeMag=0;
function shake(frames, mag) { shakeF=frames; shakeMag=mag; }

// â”€â”€ BACKGROUND â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const STARS = Array.from({length:55},()=>({x:Math.random()*W, y:Math.random()*H*0.55, r:Math.random()*1.4+0.3, fl:Math.random()*Math.PI*2}));
const FLIES = Array.from({length:14},()=>({x:Math.random()*W, y:H*0.12+Math.random()*H*0.38, vx:(Math.random()-0.5)*0.3, vy:(Math.random()-0.5)*0.2, ph:Math.random()*Math.PI*2}));
const DTREES = Array.from({length:14},(_, i)=>({x:i*65+Math.random()*30, h:110+Math.random()*70, w:28+Math.random()*18}));
const MIDMUSH = Array.from({length:8},()=>({x:Math.random()*W, y:GY-20-Math.random()*35, r:9+Math.random()*11}));
let bgX = 0;

function drawBG(spd) {
  const t = Date.now()*0.001;
  // Sky
  const sky = ctx.createLinearGradient(0,0,0,H*0.72);
  sky.addColorStop(0,'#0d1b2a'); sky.addColorStop(1,'#1a2e1a');
  ctx.fillStyle=sky; ctx.fillRect(0,0,W,H);

  // Stars
  STARS.forEach(s => {
    const a = 0.5+0.5*Math.sin(s.fl+t*2);
    ctx.globalAlpha=a; ctx.fillStyle='#f9c784';
    ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill();
  }); ctx.globalAlpha=1;

  // Fireflies
  FLIES.forEach(f => {
    f.x+=f.vx; f.y+=f.vy; f.ph+=0.05;
    if(f.x<0) f.x=W; if(f.x>W) f.x=0;
    ctx.globalAlpha = 0.4+0.6*Math.abs(Math.sin(f.ph));
    ctx.fillStyle='#a8ff78';
    ctx.beginPath(); ctx.arc(f.x,f.y,2,0,Math.PI*2); ctx.fill();
  }); ctx.globalAlpha=1;

  // Distant trees
  const tOff = bgX*0.08;
  DTREES.forEach(tr => {
    const tx = ((tr.x - tOff%W + W*3)%(W+100))-50;
    ctx.fillStyle='#0f2010';
    ctx.fillRect(tx-tr.w/6, GY-tr.h, tr.w/3, tr.h);
    ctx.beginPath(); ctx.ellipse(tx,GY-tr.h,tr.w/2,tr.h*0.55,0,0,Math.PI*2); ctx.fill();
  });

  // Mid mushrooms â€” solid shapes with outline
  const mOff = bgX*0.28;
  MIDMUSH.forEach(m => {
    const mx = ((m.x - mOff%(W+80) + W*3)%(W+80));
    const gl = 0.5+0.5*Math.sin(t*1.5+m.x);
    // Small glow dot only (no radial gradient blur)
    ctx.fillStyle=`rgba(168,255,120,${0.12+gl*0.08})`;
    ctx.beginPath(); ctx.arc(mx,m.y-m.r*0.5,m.r*1.5,0,Math.PI*2); ctx.fill();
    // Mushroom stem
    ctx.fillStyle='rgba(80,140,60,0.7)'; ctx.fillRect(mx-m.r*0.25,m.y,m.r*0.5,m.r*0.7);
    // Cap â€” solid
    ctx.fillStyle=`rgba(120,210,80,${0.55+gl*0.1})`;
    ctx.beginPath(); ctx.arc(mx,m.y,m.r,Math.PI,0); ctx.fill();
    ctx.strokeStyle='rgba(0,0,0,0.25)'; ctx.lineWidth=1; ctx.stroke();
  });

  // Mist â€” very subtle, single pass
  for(let i=0;i<2;i++){
    const mx=((i*380-bgX*0.18+W*3)%(W+200))-100;
    const my=GY-6+Math.sin(t+i)*4;
    ctx.globalAlpha=0.04; ctx.fillStyle='#a8ffc8';
    ctx.beginPath(); ctx.ellipse(mx,my,90,16,0,0,Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha=1;

  // Near foliage
  const lOff = bgX*0.75;
  for(let i=0;i<12;i++){
    const lx=((i*85-lOff%(W+100)+W*3)%(W+100));
    const ly=GY-3-Math.abs(Math.sin(i*2.3+t))*14;
    ctx.fillStyle='rgba(25,70,18,0.72)';
    ctx.beginPath(); ctx.ellipse(lx,ly,14,6,Math.sin(i)*0.5,0,Math.PI*2); ctx.fill();
  }

  // Ground
  ctx.fillStyle='#2d4a1e'; ctx.fillRect(0,GY,W,H-GY);
  // Crisp top edge line
  ctx.strokeStyle='rgba(140,255,100,0.6)'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(0,GY); ctx.lineTo(W,GY); ctx.stroke();
  // Subtle inner glow strip
  ctx.fillStyle='rgba(168,255,120,0.08)'; ctx.fillRect(0,GY,W,6);
}

// â”€â”€ FOX â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Fox {
  constructor() {
    this.x=PX; this.y=GY; this.w=44; this.h=34;
    this.vy=0; this.onGround=true; this.jumping=false;
    this.jumpHeld=false; this.jumpHoldF=0; this.coyoteF=0; this.airJumps=1;
    this.scaleX=1; this.scaleY=1;
    this.animF=0; this.animT=0; this.state='run';
    this.blinkT=150; this.eyeDir=0;
    this.trail=[]; this.dead=false; this.deathT=0; this.deathParts=false;
    this.nearGlow=0; this.comboFlash=0; this.beatPulse=0;
    this.speedLines=[];
  }
  reset() {
    this.y=GY; this.vy=0; this.onGround=true; this.jumping=false;
    this.jumpHeld=false; this.jumpHoldF=0; this.coyoteF=0; this.airJumps=1;
    this.scaleX=1; this.scaleY=1; this.state='run';
    this.dead=false; this.deathT=0; this.deathParts=false;
    this.trail=[]; this.speedLines=[];
    this.nearGlow=0; this.comboFlash=0; this.beatPulse=0;
  }
  jump(held) {
    if ((this.onGround||this.coyoteF>0) && !this.jumping) {
      // First jump (from ground or coyote window)
      this.vy = held ? -9.5 : -6.2;
      this.onGround=false; this.jumping=true;
      this.jumpHeld=held; this.jumpHoldF=18; this.coyoteF=0;
      this.airJumps=1; // restore air jump on first jump
      this.state='rise'; this.scaleX=0.78; this.scaleY=1.3;
      held ? SFX.jumpFull() : SFX.jumpShort();
      return true;
    }
    if (!this.onGround && this.airJumps>0) {
      // Double jump â€” slightly weaker, no hold mechanic
      this.vy = -7.8;
      this.airJumps--;
      this.jumpHeld=false; this.jumpHoldF=0;
      this.state='rise'; this.scaleX=0.72; this.scaleY=1.35;
      // Burst of sparkle particles
      spawnParts(this.x, this.y-this.h*0.5, 8, {color:'#a8ff78', spread:3.5, life:22, grav:-0.05, angle:-Math.PI/2, aSpread:Math.PI*0.9});
      SFX.jumpFull();
      return true;
    }
    return false;
  }
  update(spd) {
    if (this.dead) {
      this.deathT++;
      if (this.deathT===4) shake(13,5);
      if (this.deathT>=4 && !this.deathParts) {
        this.deathParts=true;
        spawnParts(this.x,this.y-this.h/2,12,{color:'#e8611a',spread:6,life:55,grav:0.2});
        spawnParts(this.x,this.y-this.h/2,8,{color:'#f9c784',spread:5,life:45,grav:0.15});
        SFX.death();
      }
      return;
    }
    if (this.coyoteF>0) this.coyoteF--;
    // Gravity
    const gUp=0.36, gApex=0.14, gDown=0.56;
    this.vy += this.vy<0 ? gUp : Math.abs(this.vy)<1.5 ? gApex : gDown;
    if (this.jumpHeld && this.jumpHoldF>0 && this.vy>-1.8) { this.vy-=0.22; this.jumpHoldF--; }
    this.y += this.vy;
    if (this.y>=GY) {
      if (!this.onGround && this.vy>0) {
        this.state='land'; this.scaleX=1.45; this.scaleY=0.58;
        spawnParts(this.x,GY,7,{color:'#4a7a2a',spread:3,life:22,grav:0.08,angle:-Math.PI/2,aSpread:Math.PI*0.85});
        SFX.land();
      }
      this.y=GY; this.vy=0; this.onGround=true;
      this.coyoteF=5; this.jumping=false; this.jumpHeld=false; this.airJumps=1;
    } else { this.onGround=false; }

    // State
    if (!this.onGround) {
      if (this.vy<-2) { this.state='rise'; this.eyeDir=-1; }
      else if (Math.abs(this.vy)<=2) { this.state='apex'; this.eyeDir=0; }
      else { this.state='fall'; this.eyeDir=1; }
    } else if (this.state!=='land') { this.state='run'; this.eyeDir=0; }
    else { if(++this.animT>8){ this.state='run'; this.animT=0; } }

    // Squash/stretch
    let tx=1,ty=1;
    if (this.state==='rise') { tx=0.8; ty=1.28; }
    else if (this.state==='fall') { tx=0.84; ty=1.22; }
    else if (this.state==='land') { tx=1.45; ty=0.58; }
    else if (this.state==='apex') { tx=1.06; ty=0.94; }
    this.scaleX += (tx-this.scaleX)*0.22; this.scaleY += (ty-this.scaleY)*0.22;

    // Run anim
    if (this.onGround && this.state==='run') {
      if (++this.animT>Math.max(3,8-spd*1.5)) { this.animT=0; this.animF=(this.animF+1)%4; }
    }
    // Blink
    if (--this.blinkT<0) this.blinkT=110+Math.random()*170;

    // Trail
    this.trail.unshift({x:this.x, y:this.y});
    if (this.trail.length>7) this.trail.pop();

    // Decays
    if(this.beatPulse>0) this.beatPulse-=0.06;
    if(this.nearGlow>0) this.nearGlow-=0.05;
    if(this.comboFlash>0) this.comboFlash-=0.05;

    // Speed lines
    if (spd>=1.55) {
      if (Math.random()<0.28) this.speedLines.push({x:this.x-25-Math.random()*30,y:this.y-this.h*0.25-Math.random()*this.h*0.55,len:22+Math.random()*38,a:(spd-1.4)*0.7,life:6});
    }
    for(let i=this.speedLines.length-1;i>=0;i--){
      this.speedLines[i].x-=spd*3.5; this.speedLines[i].life--;
      if(this.speedLines[i].life<=0) this.speedLines.splice(i,1);
    }
  }
  draw() {
    // Speed lines
    this.speedLines.forEach(l => {
      ctx.strokeStyle=`rgba(248,162,61,${l.a*l.life/6})`; ctx.lineWidth=1.2;
      ctx.beginPath(); ctx.moveTo(l.x,l.y); ctx.lineTo(l.x-l.len,l.y); ctx.stroke();
    });
    // Trail
    this.trail.forEach((p,i) => {
      if(i===0) return;
      ctx.globalAlpha=(1-i/7)*0.14; ctx.fillStyle='#e8611a';
      ctx.beginPath(); ctx.ellipse(p.x,p.y-this.h/2,this.w*0.38,this.h*0.38,0,0,Math.PI*2); ctx.fill();
    }); ctx.globalAlpha=1;
    // Beat pulse
    if (this.beatPulse>0) {
      ctx.strokeStyle=`rgba(168,255,120,${this.beatPulse})`; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(this.x,this.y-this.h/2,18+(1-this.beatPulse)*38,0,Math.PI*2); ctx.stroke();
    }
    // Near miss glow
    if (this.nearGlow>0) {
      ctx.strokeStyle=`rgba(249,199,132,${this.nearGlow})`; ctx.lineWidth=3;
      ctx.beginPath(); ctx.arc(this.x,this.y-this.h/2,this.w,0,Math.PI*2); ctx.stroke();
    }
    // Combo flash
    if (this.comboFlash>0) {
      ctx.globalAlpha=this.comboFlash*0.45; ctx.fillStyle='#f9c784';
      ctx.beginPath(); ctx.arc(this.x,this.y-this.h/2,this.w*1.3,0,Math.PI*2); ctx.fill();
      ctx.globalAlpha=1;
    }
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.scale(this.scaleX, this.scaleY);
    this._drawBody();
    ctx.restore();
  }
  _drawBody() {
    const h=this.h, w=this.w, f=this.animF;
    // Helper: draw shape then stroke it for crisp outline
    const fill = (col) => { ctx.fillStyle=col; ctx.fill(); };
    const outline = (col='rgba(0,0,0,0.55)', lw=1) => { ctx.strokeStyle=col; ctx.lineWidth=lw/this.scaleX; ctx.stroke(); };

    // â”€â”€ Tail â”€â”€
    const wag = this.state==='run' ? Math.sin(f*1.6)*0.38 : this.state==='rise' ? -0.55 : 0.25;
    ctx.beginPath(); ctx.ellipse(-w*0.52,-h*0.22,6,18,wag,0,Math.PI*2);
    fill('#e8611a'); outline();
    // Tail tip
    ctx.beginPath(); ctx.ellipse(-w*0.54,-h*0.54,5,6,wag-0.1,0,Math.PI*2);
    fill('#f0f0f0'); outline();

    // â”€â”€ Body â”€â”€
    ctx.beginPath(); ctx.ellipse(0,-h*0.38,w*0.44,h*0.4,0,0,Math.PI*2);
    fill('#e8611a'); outline();
    // Lighter belly stripe
    ctx.beginPath(); ctx.ellipse(w*0.08,-h*0.34,w*0.22,h*0.28,0.15,0,Math.PI*2);
    fill('#f5ddb0'); outline('rgba(0,0,0,0.2)');

    // â”€â”€ Legs â”€â”€
    if (this.onGround) {
      [[-w*0.18,0],[w*0.04,Math.PI],[-w*0.06,Math.PI*0.5],[w*0.16,Math.PI*1.5]].forEach(([lx,ph])=>{
        const sw=Math.sin(ph+f*Math.PI/2)*9;
        ctx.beginPath(); ctx.roundRect(lx-3.5,-h*0.04+sw,7,13,3);
        fill('#c04a10'); outline();
        // Paw
        ctx.beginPath(); ctx.ellipse(lx,-h*0.04+sw+13,4.5,3,0,0,Math.PI*2);
        fill('#1a1a1a');
      });
    } else {
      [[-w*0.16,-h*0.06],[w*0.1,-h*0.04]].forEach(([lx,ly])=>{
        ctx.beginPath(); ctx.roundRect(lx-3.5,ly,7,11,3);
        fill('#c04a10'); outline();
        ctx.beginPath(); ctx.ellipse(lx,ly+11,4.5,3,0,0,Math.PI*2); fill('#1a1a1a');
      });
    }

    // â”€â”€ Head â”€â”€
    ctx.beginPath(); ctx.ellipse(w*0.3,-h*0.76,w*0.3,h*0.3,0.08,0,Math.PI*2);
    fill('#e8611a'); outline();

    // â”€â”€ Ears â”€â”€
    const earT = this.state==='rise'?0.22:this.state==='fall'?0.52:0.1+Math.sin(f)*0.04;
    ctx.save(); ctx.translate(w*0.16,-h*0.95); ctx.rotate(-earT);
    ctx.beginPath(); ctx.moveTo(0,2); ctx.lineTo(-7,-17); ctx.lineTo(7,-17); ctx.closePath();
    fill('#e8611a'); outline();
    // Inner ear pink
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-4,-11); ctx.lineTo(4,-11); ctx.closePath();
    fill('#f4a0a0');
    ctx.restore();
    ctx.save(); ctx.translate(w*0.4,-h*0.92); ctx.rotate(earT*0.4);
    ctx.beginPath(); ctx.moveTo(0,2); ctx.lineTo(-6,-15); ctx.lineTo(8,-15); ctx.closePath();
    fill('#e8611a'); outline();
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-3,-9); ctx.lineTo(5,-9); ctx.closePath();
    fill('#f4a0a0');
    ctx.restore();

    // â”€â”€ Snout â”€â”€
    ctx.beginPath(); ctx.ellipse(w*0.54,-h*0.72,10,7,0.08,0,Math.PI*2);
    fill('#f4a261'); outline();
    // Nose
    ctx.beginPath(); ctx.ellipse(w*0.61,-h*0.72,3.5,3,0,0,Math.PI*2); fill('#1a1a1a');
    // Mouth line
    ctx.strokeStyle='rgba(0,0,0,0.5)'; ctx.lineWidth=1/this.scaleX;
    ctx.beginPath(); ctx.moveTo(w*0.61,-h*0.69); ctx.quadraticCurveTo(w*0.63,-h*0.66,w*0.66,-h*0.67); ctx.stroke();

    // â”€â”€ Eye â”€â”€
    const ey=-h*0.83+this.eyeDir*2, ex=w*0.39;
    if (this.blinkT<4) {
      ctx.fillStyle='#2a1a0a'; ctx.fillRect(ex-5.5,ey-1,11,2.5);
    } else {
      const wide=this.nearGlow>0.3;
      const er=wide?6.5:5;
      // White sclera
      ctx.beginPath(); ctx.arc(ex,ey,er+1,0,Math.PI*2); fill('#fff'); outline();
      // Iris
      ctx.beginPath(); ctx.arc(ex,ey,er,0,Math.PI*2); fill('#2a1a0a');
      // Highlight
      ctx.beginPath(); ctx.arc(ex+2,ey-1.5,1.8,0,Math.PI*2); fill('#fff');
    }
  }
  get hitbox() { return {x:this.x-this.w*0.32, y:this.y-this.h*0.95, w:this.w*0.64, h:this.h*0.9}; }
}

// â”€â”€ OBSTACLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class FairyTrap {
  constructor(x, yOff=0) {
    this.x=x; this.y=GY-yOff; this.w=22; this.h=24;
    this.ph=Math.random()*Math.PI*2; this.alive=true; this.passed=false;
    this.warnFlash=0; this.sparks=[];
  }
  update(spd, beatProg) {
    this.x-=spd; this.ph+=0.04;
    if(beatProg<0.07){ this.warnFlash=1; }
    if(this.warnFlash>0.85 && Math.random()<0.3){ this.sparks.push({x:this.x+(Math.random()-0.5)*this.w,y:this.y-Math.random()*this.h,vx:(Math.random()-0.5)*1.5,vy:-1-Math.random(),life:18}); SFX.fairy(); }
    this.warnFlash=Math.max(0,this.warnFlash-0.05);
    for(let i=this.sparks.length-1;i>=0;i--){ const s=this.sparks[i]; s.x+=s.vx; s.y+=s.vy; if(--s.life<=0) this.sparks.splice(i,1); }
    if(this.x+this.w<0) this.alive=false;
  }
  draw() {
    const bx=this.x, by=this.y, gl=0.6+0.4*Math.sin(this.ph);
    // Subtle glow only when warning
    if(this.warnFlash>0.3){
      ctx.globalAlpha=this.warnFlash*0.25; ctx.fillStyle='#ffb0c0';
      ctx.beginPath(); ctx.arc(bx,by-this.h/2,this.w*1.4,0,Math.PI*2); ctx.fill();
      ctx.globalAlpha=1;
    }
    // Stem
    ctx.strokeStyle='#3a7a20'; ctx.lineWidth=2.5;
    ctx.beginPath(); ctx.moveTo(bx,by); ctx.lineTo(bx,by-this.h*0.38); ctx.stroke();
    // 5 petals with solid fill + outline
    const pY=by-this.h*0.65;
    for(let i=0;i<5;i++){
      const a=(i/5)*Math.PI*2+this.ph*0.5;
      const pc=this.warnFlash>0.5?'#ff80a0':'#ff9ab8';
      ctx.beginPath(); ctx.ellipse(bx+Math.cos(a)*8,pY+Math.sin(a)*8,5,9,a,0,Math.PI*2);
      ctx.fillStyle=pc; ctx.fill();
      ctx.strokeStyle='rgba(0,0,0,0.4)'; ctx.lineWidth=1; ctx.stroke();
    }
    // Center disc
    ctx.beginPath(); ctx.arc(bx,pY,5.5,0,Math.PI*2);
    ctx.fillStyle='#f9c784'; ctx.fill();
    ctx.strokeStyle='rgba(0,0,0,0.5)'; ctx.lineWidth=1; ctx.stroke();
    // Sparkles
    this.sparks.forEach(s=>{ ctx.globalAlpha=s.life/18; ctx.fillStyle='#f9c784'; ctx.beginPath(); ctx.arc(s.x,s.y,2,0,Math.PI*2); ctx.fill(); }); ctx.globalAlpha=1;
  }
  get hitbox() { return {x:this.x-9, y:this.y-this.h, w:18, h:this.h*0.88}; }
}

class VineWhip {
  constructor(x, phOff=0) {
    this.x=x; this.ancY=28; this.len=85+Math.random()*28;
    this.angle=-Math.PI/2; this.swing=Math.PI/3; this.ph=phOff;
    this.alive=true; this.passed=false;
  }
  update(spd, beatProg) {
    this.x-=spd;
    this.angle=-Math.PI/2+Math.sin(beatProg*Math.PI*2+this.ph)*this.swing;
    if(this.x+this.len<0) this.alive=false;
  }
  get tipX(){ return this.x+Math.cos(this.angle)*this.len; }
  get tipY(){ return this.ancY+Math.sin(this.angle)*this.len; }
  draw() {
    // Dark outline pass for the vine
    ctx.lineCap='round';
    ctx.strokeStyle='rgba(0,0,0,0.45)'; ctx.lineWidth=8;
    ctx.beginPath();
    for(let i=0;i<=8;i++){
      const tt=i/8, sx=this.x+Math.cos(this.angle)*this.len*tt;
      const sy=this.ancY+Math.sin(this.angle)*this.len*tt+Math.sin(tt*Math.PI)*12;
      i===0?ctx.moveTo(sx,sy):ctx.lineTo(sx,sy);
    }
    ctx.stroke();
    // Main vine
    ctx.strokeStyle='#3d8a22'; ctx.lineWidth=5;
    ctx.beginPath();
    for(let i=0;i<=8;i++){
      const tt=i/8, sx=this.x+Math.cos(this.angle)*this.len*tt;
      const sy=this.ancY+Math.sin(this.angle)*this.len*tt+Math.sin(tt*Math.PI)*12;
      i===0?ctx.moveTo(sx,sy):ctx.lineTo(sx,sy);
    }
    ctx.stroke();
    // Leaves
    for(let i=2;i<=6;i++){
      const tt=i/8, lx=this.x+Math.cos(this.angle)*this.len*tt;
      const ly=this.ancY+Math.sin(this.angle)*this.len*tt+Math.sin(tt*Math.PI)*12;
      ctx.save(); ctx.translate(lx,ly); ctx.rotate(this.angle+(i%2?0.55:-0.55));
      ctx.beginPath(); ctx.ellipse(0,0,7,3.5,0,0,Math.PI*2);
      ctx.fillStyle='#2a6a10'; ctx.fill();
      ctx.strokeStyle='rgba(0,0,0,0.3)'; ctx.lineWidth=0.8; ctx.stroke();
      ctx.restore();
    }
    // Glowing tip â€” solid circle, no radial gradient
    ctx.beginPath(); ctx.arc(this.tipX,this.tipY,7,0,Math.PI*2);
    ctx.fillStyle='#a8ff78'; ctx.fill();
    ctx.strokeStyle='rgba(0,0,0,0.4)'; ctx.lineWidth=1; ctx.stroke();
  }
  get hitbox() {
    const t=0.55, mx=this.x+Math.cos(this.angle)*this.len*t, my=this.ancY+Math.sin(this.angle)*this.len*t;
    return {x:Math.min(mx,this.tipX)-7, y:my, w:Math.abs(this.tipX-mx)+14, h:this.tipY-my+8};
  }
}

class BouncingMushroom {
  constructor(x, phOff=0) {
    this.x=x; this.baseY=GY; this.y=GY;
    this.bh=58; this.ph=phOff; this.w=36; this.capH=20;
    this.alive=true; this.passed=false;
  }
  update(spd, beatProg) {
    this.x-=spd;
    const t=(beatProg+this.ph)%1;
    this.y=this.baseY-Math.max(0,Math.sin(t*Math.PI))*this.bh;
    if(this.x+this.w<0) this.alive=false;
  }
  get up(){ return (this.baseY-this.y)/this.bh; }
  draw() {
    const u=this.up, bx=this.x, by=this.y;
    const sH=18+(1-u)*8, sW=12+u*3;
    // Stem with outline
    ctx.beginPath(); ctx.rect(bx-sW/2,by-sH,sW,sH);
    ctx.fillStyle='#c8c8a0'; ctx.fill();
    ctx.strokeStyle='rgba(0,0,0,0.45)'; ctx.lineWidth=1; ctx.stroke();
    // Cap
    const cY=by-sH, cSY=1-u*0.28, cSX=1+u*0.22;
    ctx.save(); ctx.translate(bx,cY); ctx.scale(cSX,cSY);
    // Cap underside (dark shadow)
    ctx.beginPath(); ctx.ellipse(0,0,this.w/2,this.capH*0.35,0,0,Math.PI);
    ctx.fillStyle='#7a1010'; ctx.fill();
    // Cap top
    ctx.beginPath(); ctx.ellipse(0,0,this.w/2,this.capH,0,Math.PI,0);
    ctx.fillStyle='#d42800'; ctx.fill();
    ctx.strokeStyle='rgba(0,0,0,0.55)'; ctx.lineWidth=1.2; ctx.stroke();
    // Spots with outline
    ctx.fillStyle='#fff';
    [[-8,-8],[8,-8],[0,-14],[-13,-4],[13,-4]].forEach(([sx,sy])=>{
      ctx.beginPath(); ctx.arc(sx,sy,3.5,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(0,0,0,0.3)'; ctx.lineWidth=0.8; ctx.stroke();
    });
    // Glow rim only when raised
    if(u>0.15){
      ctx.beginPath(); ctx.ellipse(0,0,this.w/2+2,this.capH+2,0,Math.PI,0);
      ctx.strokeStyle=`rgba(168,255,120,${u*0.7})`; ctx.lineWidth=2; ctx.stroke();
    }
    ctx.restore();
  }
  get hitbox() {
    if(this.up<0.18) return {x:0,y:0,w:0,h:0};
    const sH=18;
    return {x:this.x-this.w/2, y:this.y-sH-this.capH, w:this.w, h:this.capH+sH};
  }
}

class Platform {
  constructor(x, len) { this.x=x; this.y=GY-72; this.len=len; this.alive=true; this.passed=false; }
  update(spd) { this.x-=spd; if(this.x+this.len<0) this.alive=false; }
  draw() {
    ctx.fillStyle='#2d4a1e'; ctx.fillRect(this.x,this.y,this.len,14);
    const g=ctx.createLinearGradient(0,this.y-2,0,this.y+3);
    g.addColorStop(0,'rgba(168,255,120,0.55)'); g.addColorStop(1,'rgba(168,255,120,0)');
    ctx.fillStyle=g; ctx.fillRect(this.x,this.y-2,this.len,5);
  }
  get hitbox(){ return {x:this.x,y:this.y,w:this.len,h:14}; }
}

// â”€â”€ CHUNK SPAWNER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnChunk(id, sx) {
  const obs=[], plats=[];
  switch(id){
    case 1: obs.push(new FairyTrap(sx)); break;
    case 2: obs.push(new FairyTrap(sx)); obs.push(new FairyTrap(sx+82)); break;
    case 3: obs.push(new BouncingMushroom(sx)); break;
    case 4: obs.push(new VineWhip(sx+30)); break;
    case 5: obs.push(new FairyTrap(sx)); obs.push(new VineWhip(sx+95)); break;
    case 6: obs.push(new BouncingMushroom(sx,0)); obs.push(new BouncingMushroom(sx+92,0.5)); break;
    case 7: obs.push(new FairyTrap(sx)); obs.push(new FairyTrap(sx+50)); obs.push(new FairyTrap(sx+100)); break;
    case 8: obs.push(new VineWhip(sx+20)); obs.push(new BouncingMushroom(sx+155)); break;
    case 9: plats.push(new Platform(sx,185)); break;
    case 10: obs.push(new FairyTrap(sx)); obs.push(new FairyTrap(sx+68)); break;
    case 11: break; // empty
    case 12: obs.push(new FairyTrap(sx)); obs.push(new BouncingMushroom(sx+72)); obs.push(new FairyTrap(sx+150)); obs.push(new BouncingMushroom(sx+222)); break;
  }
  return {obs, plats};
}
const EASY=[1,3,11], MED=[2,4,5,6,9], HARD=[7,8,10,12];
function pool(elapsed){ return elapsed<30?EASY:elapsed<90?[...EASY,...MED]:[...EASY,...MED,...HARD]; }
function rndChunk(elapsed){ const p=pool(elapsed); return p[Math.floor(Math.random()*p.length)]; }

// â”€â”€ BOSS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Boss {
  constructor(type) {
    this.type=type; this.timer=0;
    this.dur=type===1?900:type===2?1200:1500;
    this.active=true; this.defeated=false;
    this.x=W+60; this.ph=0; this.proj=[]; this.nameCard=65;
  }
  get hp(){ return 1-this.timer/this.dur; }
  update(beatProg) {
    if(!this.active) return;
    this.timer++; this.ph+=0.03; if(this.nameCard>0) this.nameCard--;
    if(this.x>W*0.72) this.x-=1.8;
    if(this.type===1 && beatProg<0.05 && Math.random()<0.75)
      this.proj.push({x:this.x+(Math.random()-0.5)*60,y:75,vy:2+Math.random()*2,r:8});
    for(let i=this.proj.length-1;i>=0;i--){ this.proj[i].y+=this.proj[i].vy; if(this.proj[i].y>GY) this.proj.splice(i,1); }
    if(this.timer>=this.dur){ this.defeated=true; this.active=false; SFX.bossOut(); }
  }
  draw() {
    const bx=this.x, by=H*0.28, t=Date.now()*0.001;
    if(this.type===1){
      // Fairy Queen
      ctx.globalAlpha=0.55;
      ctx.fillStyle='rgba(255,192,255,0.4)';
      ctx.beginPath(); ctx.ellipse(bx-50,by,48,26,-0.4,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(bx+50,by,48,26,0.4,0,Math.PI*2); ctx.fill();
      ctx.globalAlpha=1;
      ctx.fillStyle='#d4a0ff'; ctx.beginPath(); ctx.ellipse(bx,by,26,42,0,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#f4c2c2'; ctx.beginPath(); ctx.arc(bx,by-52,21,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#f9c784';
      for(let i=-2;i<=2;i++){ ctx.beginPath(); ctx.moveTo(bx+i*8,by-70); ctx.lineTo(bx+i*8-4,by-78-(i===0?7:0)); ctx.lineTo(bx+i*8+4,by-78-(i===0?7:0)); ctx.closePath(); ctx.fill(); }
      this.proj.forEach(p=>{
        const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r);
        g.addColorStop(0,'#f9c784'); g.addColorStop(1,'rgba(255,192,203,0)');
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
      });
    } else if(this.type===2){
      ctx.strokeStyle='#2a5a10'; ctx.lineWidth=20; ctx.lineCap='round';
      ctx.beginPath();
      for(let i=0;i<=8;i++){
        const tt=i/8, sx=bx-tt*210, sy=by-55+Math.sin(tt*Math.PI*3+this.ph)*65;
        i===0?ctx.moveTo(sx,sy):ctx.lineTo(sx,sy);
      }
      ctx.stroke();
      const hy=by-55+Math.sin(this.ph)*65;
      ctx.fillStyle='#3a7a20'; ctx.beginPath(); ctx.arc(bx,hy,23,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#a8ff78'; ctx.beginPath(); ctx.arc(bx+8,hy-7,5,0,Math.PI*2); ctx.fill();
    } else {
      const hop=Math.abs(Math.sin(this.ph*0.5))*42;
      ctx.fillStyle='#8b0000'; ctx.beginPath(); ctx.ellipse(bx,by-52-hop,52,36,0,Math.PI,0); ctx.fill();
      ctx.fillStyle='#fff';
      [[0,-72],[-22,-62],[22,-62],[-36,-54],[36,-54]].forEach(([sx,sy])=>{ ctx.beginPath(); ctx.arc(bx+sx,sy-hop,7,0,Math.PI*2); ctx.fill(); });
      ctx.fillStyle='#c8c890'; ctx.fillRect(bx-23,by-52-hop,46,62);
      ctx.fillStyle='#000';
      ctx.beginPath(); ctx.arc(bx-11,by-57-hop,6,0,Math.PI*2); ctx.arc(bx+11,by-57-hop,6,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#f9c784'; ctx.beginPath(); ctx.arc(bx,by-100-hop,12,0,Math.PI*2); ctx.fill();
    }
    if(this.nameCard>0){
      const a=Math.min(1,this.nameCard/20);
      ctx.globalAlpha=a; ctx.fillStyle='rgba(0,0,0,0.72)'; ctx.fillRect(W/2-145,H/2-32,290,64);
      ctx.fillStyle='#f9c784'; ctx.font='bold 24px serif'; ctx.textAlign='center';
      ctx.fillText(['','THE FAIRY QUEEN','THE VINE TITAN','THE MUSHROOM KING'][this.type],W/2,H/2+10);
      ctx.textAlign='left'; ctx.globalAlpha=1;
    }
  }
  projHitboxes(){ return this.proj.map(p=>({x:p.x-p.r,y:p.y-p.r,w:p.r*2,h:p.r*2})); }
}

// â”€â”€ GHOST SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const GK='enchanted_sprint_ghosts', HSK='enchanted_sprint_highscore';
function loadGhosts(){ try{return JSON.parse(localStorage.getItem(GK)||'[]');}catch{return[];} }
function saveGhost(run){ let g=loadGhosts(); g.push(run); g.sort((a,b)=>b.score-a.score); if(g.length>5)g=g.slice(0,5); localStorage.setItem(GK,JSON.stringify(g)); }
function loadHS(){ try{return JSON.parse(localStorage.getItem(HSK));}catch{return null;} }
function saveHS(score,grade){ localStorage.setItem(HSK,JSON.stringify({score,date:new Date().toLocaleDateString(),rhythmGrade:grade})); }

let ghostData=null, ghostFrame=0, runFrames=[];
function drawGhost(fi){
  if(!ghostData||fi>=ghostData.frames.length) return;
  const gf=ghostData.frames[fi]; if(!gf) return;
  ctx.globalAlpha=0.38;
  ctx.fillStyle='rgba(79,195,247,0.7)';
  ctx.beginPath(); ctx.ellipse(PX,gf.y-14,15,12,0,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(PX+10,gf.y-25,10,9,0.1,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='rgba(79,195,247,0.5)'; ctx.lineWidth=1;
  const shimmer=0.1+0.1*Math.sin(Date.now()*0.008);
  ctx.globalAlpha=shimmer;
  ctx.beginPath(); ctx.arc(PX,gf.y-14,19,0,Math.PI*2); ctx.stroke();
  ctx.globalAlpha=1;
}

// â”€â”€ RHYTHM / SCORING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let score=0,meters=0,combo=0,mult=1,rHits=0,rMiss=0,hs=null;
function beatProg(ms){ return (ms%BEAT)/BEAT; }
function beatDist(ms){ const p=beatProg(ms); return Math.min(p,1-p); }
function getGrade(){ const tot=rHits+rMiss; if(!tot)return'C'; const r=rHits/tot; return r>=0.9?'S':r>=0.7?'A':r>=0.5?'B':'C'; }

// â”€â”€ INPUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const K={};
let spaceDown=false, spaceJust=false;
document.addEventListener('keydown',e=>{
  if(e.code==='Space'||e.code==='ArrowUp'){ e.preventDefault(); if(!K.Space){ spaceJust=true; } K.Space=true; spaceDown=true; ensureAudio(); }
  if(e.code==='Escape'){ ensureAudio(); if(GS==='playing')GS='paused'; else if(GS==='paused')GS='playing'; }
  K[e.code]=true;
});
document.addEventListener('keyup',e=>{ if(e.code==='Space'||e.code==='ArrowUp'){K.Space=false;spaceDown=false;} K[e.code]=false; });

// â”€â”€ GAME STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let GS='start'; // start playing paused gameover
let fox=new Fox(), obstacles=[], plats=[], boss=null, bossMode=false;
let startTime=0, elMs=0, elapsed=0, spd=1, baseSpd=4;
let spawnCD=0, nextBossAt=60, beatCount=0, lastBeatMs=0;
const BTNS={};

function resetGame(){
  fox.reset(); obstacles=[]; plats=[]; boss=null; bossMode=false;
  startTime=Date.now(); elMs=0; elapsed=0; spd=1; spawnCD=350; nextBossAt=60;
  score=0; meters=0; combo=0; mult=1; rHits=0; rMiss=0;
  bgX=0; parts.length=0; floats.length=0;
  runFrames=[]; ghostFrame=0; beatCount=0; lastBeatMs=0; hs=loadHS();
}

function startGame(){ resetGame(); GS='playing'; }

// â”€â”€ HUD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function label(text, x, y, col, size=20, align='left'){
  ctx.font=`bold ${size}px 'Georgia', serif`;
  ctx.textAlign=align;
  // Crisp dark outline instead of shadowBlur
  ctx.fillStyle='rgba(0,0,0,0.55)';
  ctx.fillText(text, x+1, y+1);
  ctx.fillStyle=col;
  ctx.fillText(text, x, y);
  ctx.textAlign='left';
}
function drawHUD(){
  label(`â­ ${Math.floor(score)}`, 14, 32, '#f9c784', 20, 'left');
  label(`Best: ${hs?Math.floor(hs.score):0}`, W-14, 32, '#c084fc', 18, 'right');
  // Beat pulse indicator â€” solid ring, no blur
  const bp=beatProg(elMs), pulse=10+Math.sin(bp*Math.PI*2)*4;
  ctx.globalAlpha=0.3+bp*0.7; ctx.strokeStyle='#f9c784'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.arc(W/2,24,pulse,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1;
  // Combo
  if(combo>=2){ label(`Ã—${mult.toFixed(1)} Ã—${combo}`,14,56,'#a8ff78',15,'left'); }
  // Ghost indicator
  if(ghostData){ const gs=ghostData.frames[Math.min(Math.floor(ghostFrame),ghostData.frames.length-1)]?.score||0; label(score>gs?'ðŸ‘» Ahead!':'ðŸ‘» Behind!',14,H-14,'#4fc3f7',13,'left'); }
  // Boss bar
  if(bossMode&&boss){
    const bw=300,bh=16,bx=W/2-150,by2=48;
    ctx.fillStyle='rgba(0,0,0,0.8)'; ctx.fillRect(bx-2,by2-2,bw+4,bh+4);
    ctx.fillStyle='#cc0000'; ctx.fillRect(bx,by2,bw*boss.hp,bh);
    ctx.strokeStyle='#ff6040'; ctx.lineWidth=1; ctx.strokeRect(bx,by2,bw,bh);
    label('BOSS HP',W/2,by2+bh-3,'#fff',10,'center');
  }
}

// â”€â”€ BUTTON HELPER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function btn(label, cx, cy, col, id){
  const bw=210,bh=46,bx=cx-bw/2,by=cy-bh/2;
  ctx.globalAlpha=0.18; ctx.fillStyle=col; ctx.fillRect(bx,by,bw,bh);
  ctx.globalAlpha=1; ctx.strokeStyle=col; ctx.lineWidth=2;
  ctx.beginPath(); ctx.rect(bx,by,bw,bh); ctx.stroke();
  ctx.fillStyle=col; ctx.font='bold 18px serif'; ctx.textAlign='center'; ctx.fillText(label,cx,cy+7);
  BTNS[id]={x:bx,y:by,w:bw,h:bh};
}
function hit(id,mx,my){ const b=BTNS[id]; return b&&mx>=b.x&&mx<=b.x+b.w&&my>=b.y&&my<=b.y+b.h; }

// â”€â”€ SCREENS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let menuT=0;
function drawStart(){
  drawBG(0); menuT+=0.07;
  // Animated fox
  ctx.save(); ctx.translate(W/2-70,GY); ctx.scale(1.5,1.5);
  const mf=new Fox(); mf.animF=Math.floor(menuT)%4; mf._drawBody(); ctx.restore();
  // Title (dark backing rect for crispness)
  ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(W/2-220,60,440,68);
  label('Enchanted Sprint',W/2,100,'#f9c784',46,'center');
  label('Fantasy Forest Endless Runner',W/2,118,'#a8ff78',14,'center');
  if(hs){ label(`Best: ${Math.floor(hs.score)} pts  â€¢  ${hs.rhythmGrade} grade  â€¢  ${hs.date}`,W/2,140,'#c084fc',13,'center'); }
  btn('â–¶  RUN!',W/2,210,'#f9c784','run');
  if(loadGhosts().length>0) btn('ðŸ‘»  Ghost Races',W/2,265,'#4fc3f7','ghost');
  btn('SPACE / click  â€¢  hold = big jump',W/2,320,'rgba(200,200,200,0.5)','howto');
  label('ESC = pause',W/2,370,'rgba(255,255,255,0.4)',12,'center');
}

function drawGameOver(){
  ctx.fillStyle='rgba(0,0,0,0.75)'; ctx.fillRect(0,0,W,H);
  label('GAME OVER',W/2,88,'#e8611a',42,'center');
  label(`${Math.floor(score)} pts`,W/2,130,'#f9c784',30,'center');
  label(`${Math.floor(meters)}m traveled`,W/2,158,'#a8ff78',16,'center');
  const grade=getGrade(); const gc={S:'#f9c784',A:'#a8ff78',B:'#4fc3f7',C:'#c084fc'}[grade];
  label(`Rhythm Grade: ${grade}`,W/2,195,gc,30,'center');
  if(hs&&score>=hs.score){ label('âœ¨ NEW HIGH SCORE! âœ¨',W/2,228,'#f9c784',17,'center'); }
  if(ghostData){ const gs=ghostData.score||0; label(score>gs?`ðŸ‘» Beat the ghost! (${Math.floor(gs)} pts)`:`ðŸ‘» Ghost won â€” ${Math.floor(gs)} pts`,W/2,256,score>gs?'#a8ff78':'#4fc3f7',15,'center'); }
  btn('â†©  Try Again',W/2,294,'#e8611a','retry');
  btn('ðŸ‘»  Race Your Ghost',W/2,346,'#4fc3f7','raceghost');
  btn('ðŸ   Menu',W/2,H-28,'#c084fc','menu');
}

function drawPause(){
  ctx.fillStyle='rgba(0,0,0,0.62)'; ctx.fillRect(0,0,W,H);
  label('PAUSED',W/2,138,'#f9c784',42,'center');
  btn('â–¶  Resume',W/2,200,'#a8ff78','resume');
  btn('â†©  Restart',W/2,255,'#f9c784','restart');
  btn('ðŸ   Menu',W/2,310,'#c084fc','menu');
}

// â”€â”€ CLICK HANDLER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
canvas.addEventListener('click', e=>{
  ensureAudio();
  const r=canvas.getBoundingClientRect();
  const mx=(e.clientX-r.left)*(W/r.width), my=(e.clientY-r.top)*(H/r.height);
  if(GS==='start'){
    if(hit('run',mx,my)){ ghostData=null; startGame(); }
    else if(hit('ghost',mx,my)){ const g=loadGhosts(); if(g.length){ ghostData=g[0]; } startGame(); }
  } else if(GS==='gameover'){
    if(hit('retry',mx,my)){ ghostData=null; startGame(); }
    else if(hit('raceghost',mx,my)){ const g=loadGhosts(); if(g.length) ghostData=g[0]; startGame(); }
    else if(hit('menu',mx,my)) GS='start';
  } else if(GS==='paused'){
    if(hit('resume',mx,my)) GS='playing';
    else if(hit('restart',mx,my)){ ghostData=null; startGame(); }
    else if(hit('menu',mx,my)) GS='start';
  } else if(GS==='playing'){
    spaceJust=true;
  }
});

// â”€â”€ COLLISION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function overlap(a,b){ return a.x<b.x+b.w&&a.x+a.w>b.x&&a.y<b.y+b.h&&a.y+a.h>b.y; }

// â”€â”€ MAIN LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let last=0;
hs=loadHS();

function loop(ts){
  requestAnimationFrame(loop);
  const dt=Math.min(ts-last,50); last=ts;
  let sx=0,sy=0;
  if(shakeF>0){ sx=(Math.random()-0.5)*shakeMag*2; sy=(Math.random()-0.5)*shakeMag; shakeF--; }
  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.clearRect(0,0,W,H);
  ctx.setTransform(DPR,0,0,DPR,sx*DPR,sy*DPR);

  if(GS==='start'){
    drawStart();
  } else if(GS==='playing'||GS==='paused'){
    if(GS==='playing'){ elMs=Date.now()-startTime; elapsed=elMs/1000; }
    const bp=beatProg(elMs);
    const justBeat=bp<0.06&&elMs-lastBeatMs>BEAT*0.75;
    if(justBeat&&GS==='playing'){ lastBeatMs=elMs; beatCount++; fox.beatPulse=1; SFX.beat(); }

    // Speed ramp
    spd = elapsed<30 ? 1.0+elapsed*0.005
        : elapsed<60 ? 1.15+(elapsed-30)*0.0085
        : elapsed<90 ? 1.41+(elapsed-60)*0.006
        : Math.min(2.5, 1.59+(elapsed-90)*0.004);
    const speed=baseSpd*spd;
    if(GS==='playing') bgX+=speed;

    // Spawn
    if(!bossMode&&GS==='playing'){
      spawnCD-=speed;
      if(spawnCD<=0){
        const {obs,plats:ps}=spawnChunk(rndChunk(elapsed),W+80);
        obstacles.push(...obs); plats.push(...ps);
        spawnCD=240+Math.random()*140;
      }
    }

    // Boss trigger
    if(!bossMode&&GS==='playing'&&elapsed>=nextBossAt){
      const bt=nextBossAt===60?1:nextBossAt===120?2:3;
      if(bt<=3){ boss=new Boss(bt); bossMode=true; nextBossAt+=60; SFX.bossIn(); shake(16,4); }
    }

    if(GS==='playing'){
      // Jump input
      if(spaceJust){
        fox.jump(spaceDown);
        const bd=beatDist(elMs);
        if(bd<0.16){
          score+=50*mult; combo++; mult=Math.min(3,1+combo*0.1); rHits++;
          fox.beatPulse=1.2;
          spawnFloat(bd<0.08?'PERFECT!':'GOOD!',fox.x+35,fox.y-65,'#f9c784');
          SFX.onBeat();
          if(combo%5===0){ fox.comboFlash=1; SFX.combo(Math.floor(combo/5)); }
        } else { combo=0; mult=1; rMiss++; spawnFloat('MISS!',fox.x+35,fox.y-65,'#ff6060'); }
      }
      spaceJust=false;

      fox.update(spd);
      meters+=speed/60; score+=speed/60*mult;

      // Update & check obstacles
      const fhb=fox.hitbox;
      for(let i=obstacles.length-1;i>=0;i--){
        const o=obstacles[i];
        o.update(speed,bp);
        if(!o.alive){ obstacles.splice(i,1); continue; }
        if(!o.passed&&o.x<fox.x-8){
          o.passed=true;
          const ohb=o.hitbox, cx2=ohb.x+ohb.w/2, fcx=fhb.x+fhb.w/2;
          if(Math.abs(cx2-fcx)<28){ score+=25*mult; fox.nearGlow=1; spawnFloat('+25 NEAR MISS',fox.x+35,fox.y-55,'#a8ff78'); SFX.nearMiss(); }
        }
        if(!fox.dead&&overlap(fhb,o.hitbox)){ fox.dead=true; }
      }

      // Platforms
      for(let i=plats.length-1;i>=0;i--){
        const p=plats[i]; p.update(speed);
        if(!p.alive){ plats.splice(i,1); continue; }
        if(fox.vy>=0&&fox.x>p.x-8&&fox.x<p.x+p.len+8&&fox.y>=p.y&&fox.y<=p.y+18){
          fox.y=p.y; fox.vy=0; fox.onGround=true; fox.coyoteF=5; fox.airJumps=1;
        }
      }

      // Boss
      if(bossMode&&boss){
        boss.update(bp);
        if(boss.type===1&&!fox.dead) for(const pb of boss.projHitboxes()) if(overlap(fhb,pb)){ fox.dead=true; break; }
        if(boss.type===3&&!fox.dead&&fox.onGround&&Math.abs(Math.sin(boss.ph*0.5))<0.06) fox.dead=true;
        if(boss.defeated){
          bossMode=false;
          const bonus=boss.type===1?500:boss.type===2?1000:1500;
          score+=bonus; spawnFloat(`BOSS DOWN! +${bonus}`,W/2,H/2,'#f9c784'); boss=null; spawnCD=200;
        }
      }

      // Death
      if(fox.dead){
        fox.update(spd);
        if(fox.deathT>65){
          const grade=getGrade();
          if(!hs||score>hs.score){ saveHS(score,grade); hs=loadHS(); }
          saveGhost({score,date:new Date().toLocaleDateString(),frames:runFrames});
          GS='gameover';
        }
      }

      // Record ghost
      if(runFrames.length%2===0) runFrames.push({x:fox.x,y:fox.y,score:Math.floor(score)});
    } // end playing

    drawBG(speed);
    plats.forEach(p=>p.draw());
    obstacles.forEach(o=>o.draw());
    if(ghostData){ drawGhost(Math.floor(ghostFrame)); if(GS==='playing') ghostFrame+=0.5; }
    fox.draw();
    if(bossMode&&boss) boss.draw();
    updateParts(); drawParts();
    updateFloats(); drawFloats();
    drawHUD();
    if(GS==='paused') drawPause();

  } else if(GS==='gameover'){
    drawBG(0); fox.draw();
    updateParts(); drawParts(); updateFloats(); drawFloats();
    drawGameOver();
  }

}

requestAnimationFrame(loop);
</script>
</body>
</html>
