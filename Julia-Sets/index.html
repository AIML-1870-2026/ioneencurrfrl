<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Groovy Julia Set Explorer</title>
<link href="https://fonts.googleapis.com/css2?family=Righteous&family=Fredoka+One&display=swap" rel="stylesheet">
<style>
/* ===== RESET & BASE ===== */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: 'Righteous', cursive;
  background: linear-gradient(135deg, #1a0a1f, #4A0E4E, #1a0a1f);
  background-size: 400% 400%;
  animation: bgShift 60s ease infinite;
  color: #FFB6C1;
  min-height: 100vh;
  overflow-x: hidden;
  user-select: none;
}

@keyframes bgShift {
  0%, 100% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
}

/* ===== FLOATING PARTICLES ===== */
.particles {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none; z-index: 0; overflow: hidden;
}
.particle {
  position: absolute;
  font-size: 1.2rem;
  opacity: 0;
  animation: floatParticle 12s ease-in-out infinite;
}
@keyframes floatParticle {
  0% { opacity: 0; transform: translateY(100vh) rotate(0deg); }
  10% { opacity: 0.7; }
  90% { opacity: 0.7; }
  100% { opacity: 0; transform: translateY(-10vh) rotate(360deg); }
}

/* ===== LAYOUT ===== */
.app {
  position: relative; z-index: 1;
  display: flex; flex-direction: column;
  min-height: 100vh;
}

/* ===== TOP BAR ===== */
.top-bar {
  display: flex; align-items: center; justify-content: space-between;
  padding: 12px 24px;
  background: rgba(30, 5, 35, 0.85);
  backdrop-filter: blur(10px);
  border-bottom: 2px solid rgba(255, 20, 147, 0.3);
}
.logo {
  font-family: 'Fredoka One', cursive;
  font-size: 1.6rem;
  background: linear-gradient(90deg, #FF69B4, #FF1493, #FF00FF, #FF69B4);
  background-size: 200% auto;
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  background-clip: text;
  animation: shimmer 3s linear infinite;
  text-shadow: 0 0 20px rgba(255, 20, 147, 0.5);
  filter: drop-shadow(0 0 8px rgba(255,20,147,0.4));
}
@keyframes shimmer {
  to { background-position: 200% center; }
}
.top-controls { display: flex; gap: 12px; align-items: center; }

/* ===== BUTTONS ===== */
.btn {
  font-family: 'Righteous', cursive;
  border: none; cursor: pointer;
  padding: 8px 18px;
  border-radius: 30px;
  background: linear-gradient(135deg, #FF1493, #C71585);
  color: #fff;
  font-size: 0.85rem;
  transition: all 0.3s ease;
  box-shadow: 0 2px 10px rgba(255, 20, 147, 0.3);
}
.btn:hover {
  transform: scale(1.08);
  box-shadow: 0 4px 20px rgba(255, 20, 147, 0.5);
}
.btn:active { transform: scale(0.97); }
.btn.active {
  background: linear-gradient(135deg, #FF00FF, #FF1493);
  box-shadow: 0 0 20px rgba(255, 0, 255, 0.6);
  animation: pulse 1.5s ease infinite;
}
@keyframes pulse {
  0%, 100% { box-shadow: 0 0 15px rgba(255, 0, 255, 0.4); }
  50% { box-shadow: 0 0 30px rgba(255, 0, 255, 0.7); }
}

/* ===== COLOR SCHEME SELECTOR ===== */
select {
  font-family: 'Righteous', cursive;
  background: rgba(75, 0, 90, 0.8);
  color: #FFB6C1;
  border: 1px solid rgba(255, 20, 147, 0.4);
  border-radius: 20px;
  padding: 6px 14px;
  font-size: 0.85rem;
  cursor: pointer;
  outline: none;
}
select:focus { border-color: #FF1493; box-shadow: 0 0 10px rgba(255,20,147,0.3); }
select option { background: #2d0033; color: #FFB6C1; }

/* ===== MAIN CONTENT ===== */
.main {
  display: flex; flex: 1; gap: 0;
}

/* ===== SIDE PANEL ===== */
.side-panel {
  width: 300px; min-width: 300px;
  padding: 16px;
  background: rgba(20, 5, 25, 0.9);
  backdrop-filter: blur(10px);
  border-right: 2px solid rgba(255, 20, 147, 0.2);
  overflow-y: auto;
  max-height: calc(100vh - 60px);
  transition: margin-left 0.3s ease;
}
.side-panel.collapsed { margin-left: -300px; }
.section-title {
  font-family: 'Fredoka One', cursive;
  font-size: 1rem;
  color: #FF69B4;
  margin: 16px 0 10px;
  padding-bottom: 4px;
  border-bottom: 1px solid rgba(255, 105, 180, 0.3);
}
.section-title:first-child { margin-top: 0; }

/* ===== PRESET GRID ===== */
.preset-grid {
  display: grid; grid-template-columns: 1fr 1fr; gap: 8px;
}
.preset-btn {
  font-family: 'Righteous', cursive;
  border: none; cursor: pointer;
  padding: 10px 6px;
  border-radius: 18px;
  font-size: 0.72rem;
  color: #fff;
  transition: all 0.3s ease;
  text-align: center;
  line-height: 1.3;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}
.preset-btn:hover { transform: scale(1.06); filter: brightness(1.2); }
.preset-btn.selected {
  outline: 2px solid #fff;
  outline-offset: 2px;
  animation: pulse 1.5s ease infinite;
}
.preset-btn:nth-child(1) { background: linear-gradient(135deg, #FF1493, #C71585); }
.preset-btn:nth-child(2) { background: linear-gradient(135deg, #FF69B4, #DB7093); }
.preset-btn:nth-child(3) { background: linear-gradient(135deg, #FF00FF, #8B008B); }
.preset-btn:nth-child(4) { background: linear-gradient(135deg, #C71585, #800080); }
.preset-btn:nth-child(5) { background: linear-gradient(135deg, #FF1493, #4B0082); }
.preset-btn:nth-child(6) { background: linear-gradient(135deg, #DA70D6, #8B008B); }
.preset-btn:nth-child(7) { background: linear-gradient(135deg, #FFB6C1, #FF69B4); }
.preset-btn:nth-child(8) { background: linear-gradient(135deg, #FF7F50, #FF1493); }

/* ===== MORPH CONTROLS ===== */
.morph-section { display: flex; flex-direction: column; gap: 8px; }
.morph-toggle {
  font-family: 'Fredoka One', cursive;
  font-size: 1rem;
  padding: 12px;
  border-radius: 24px;
  border: none; cursor: pointer;
  background: linear-gradient(135deg, #FF00FF, #FF1493);
  color: #fff;
  transition: all 0.3s ease;
  box-shadow: 0 4px 15px rgba(255, 0, 255, 0.4);
}
.morph-toggle:hover { transform: scale(1.05); box-shadow: 0 6px 25px rgba(255, 0, 255, 0.6); }
.morph-toggle.active {
  background: linear-gradient(135deg, #00FFFF, #FF00FF);
  animation: morphPulse 2s ease infinite;
}
@keyframes morphPulse {
  0%, 100% { box-shadow: 0 0 15px rgba(0, 255, 255, 0.4); }
  50% { box-shadow: 0 0 35px rgba(255, 0, 255, 0.7); }
}

.morph-mode-btns { display: flex; gap: 6px; }
.morph-mode-btn {
  flex: 1;
  font-family: 'Righteous', cursive;
  padding: 6px; border-radius: 14px;
  border: 1px solid rgba(255,20,147,0.3);
  background: rgba(75,0,90,0.5);
  color: #FFB6C1; font-size: 0.72rem;
  cursor: pointer; transition: all 0.3s;
}
.morph-mode-btn.active {
  background: rgba(255,20,147,0.3);
  border-color: #FF1493;
  color: #fff;
}

.morph-status {
  font-size: 0.75rem;
  color: #DA70D6;
  text-align: center;
  min-height: 1.2em;
  opacity: 0.9;
}

/* ===== SLIDERS ===== */
.slider-group { margin: 6px 0; }
.slider-label {
  display: flex; justify-content: space-between; align-items: center;
  font-size: 0.78rem; margin-bottom: 4px; color: #DDA0DD;
}
.slider-value { color: #FF69B4; font-weight: bold; font-size: 0.82rem; }
input[type="range"] {
  -webkit-appearance: none; width: 100%;
  height: 6px; border-radius: 3px;
  background: linear-gradient(90deg, #8B008B, #FF1493, #FF69B4);
  outline: none; cursor: pointer;
}
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 18px; height: 18px;
  border-radius: 50%;
  background: radial-gradient(circle, #FF69B4, #FF1493);
  box-shadow: 0 0 8px rgba(255, 20, 147, 0.6);
  cursor: pointer;
  transition: transform 0.2s;
}
input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }
input[type="range"]::-moz-range-thumb {
  width: 18px; height: 18px; border: none;
  border-radius: 50%;
  background: radial-gradient(circle, #FF69B4, #FF1493);
  box-shadow: 0 0 8px rgba(255, 20, 147, 0.6);
  cursor: pointer;
}

/* ===== SPEED SLIDER LABELS ===== */
.speed-labels {
  display: flex; justify-content: space-between;
  font-size: 0.7rem; color: #C48189; margin-top: 2px;
}

/* ===== VIEW BUTTONS ===== */
.view-btns { display: flex; gap: 8px; flex-wrap: wrap; }
.view-btns .btn { flex: 1; min-width: 80px; text-align: center; font-size: 0.75rem; padding: 7px 10px; }

/* ===== CANVAS AREA ===== */
.canvas-area {
  flex: 1; display: flex; align-items: center; justify-content: center;
  padding: 20px; position: relative;
}
.canvas-wrapper {
  position: relative;
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 0 40px rgba(255, 20, 147, 0.3), 0 0 80px rgba(255, 0, 255, 0.15);
  animation: canvasGlow 4s ease infinite;
}
@keyframes canvasGlow {
  0%, 100% { box-shadow: 0 0 30px rgba(255, 20, 147, 0.25), 0 0 60px rgba(255, 0, 255, 0.1); }
  50% { box-shadow: 0 0 50px rgba(255, 20, 147, 0.45), 0 0 100px rgba(255, 0, 255, 0.25); }
}
#fractalCanvas { display: block; cursor: grab; }
#fractalCanvas:active { cursor: grabbing; }

/* ===== BOTTOM BAR ===== */
.bottom-bar {
  display: flex; align-items: center; justify-content: space-between;
  padding: 8px 24px;
  background: rgba(30, 5, 35, 0.85);
  backdrop-filter: blur(10px);
  border-top: 2px solid rgba(255, 20, 147, 0.2);
  font-size: 0.78rem; color: #DDA0DD;
  flex-wrap: wrap; gap: 8px;
}
.bottom-bar span { white-space: nowrap; }
.c-value { color: #FF69B4; font-weight: bold; }

/* ===== HELP MODAL ===== */
.modal-overlay {
  display: none; position: fixed; top: 0; left: 0;
  width: 100%; height: 100%;
  background: rgba(10, 0, 15, 0.85);
  backdrop-filter: blur(5px);
  z-index: 100;
  align-items: center; justify-content: center;
}
.modal-overlay.visible { display: flex; }
.modal {
  background: linear-gradient(135deg, #2d0033, #1a0a1f);
  border: 2px solid rgba(255, 20, 147, 0.4);
  border-radius: 24px;
  padding: 30px;
  max-width: 550px; width: 90%;
  max-height: 80vh; overflow-y: auto;
  box-shadow: 0 0 60px rgba(255, 20, 147, 0.3);
  color: #FFB6C1;
}
.modal h2 {
  font-family: 'Fredoka One', cursive;
  color: #FF69B4; margin-bottom: 16px; font-size: 1.4rem;
}
.modal p { margin-bottom: 12px; line-height: 1.6; font-size: 0.9rem; }
.modal .shortcuts {
  display: grid; grid-template-columns: auto 1fr; gap: 4px 16px;
  margin: 12px 0; font-size: 0.85rem;
}
.modal .shortcuts kbd {
  background: rgba(255,20,147,0.2); padding: 2px 8px; border-radius: 6px;
  font-family: 'Righteous', cursive; color: #FF69B4;
}
.modal-close {
  margin-top: 16px;
  font-family: 'Fredoka One', cursive;
  background: linear-gradient(135deg, #FF1493, #C71585);
  border: none; color: #fff; padding: 10px 28px;
  border-radius: 24px; cursor: pointer; font-size: 0.95rem;
  transition: all 0.3s;
}
.modal-close:hover { transform: scale(1.05); box-shadow: 0 4px 20px rgba(255,20,147,0.5); }

/* ===== TOGGLE PANEL BUTTON ===== */
.toggle-panel {
  position: absolute; left: 300px; top: 50%;
  transform: translateY(-50%);
  z-index: 10;
  background: rgba(75, 0, 90, 0.8);
  border: 1px solid rgba(255,20,147,0.3);
  color: #FF69B4; font-size: 1.2rem;
  width: 28px; height: 50px;
  border-radius: 0 12px 12px 0;
  cursor: pointer; transition: all 0.3s;
  display: flex; align-items: center; justify-content: center;
}
.toggle-panel:hover { background: rgba(255,20,147,0.3); }
.side-panel.collapsed ~ .canvas-area .toggle-panel,
.toggle-panel.shifted { left: 0; }

/* ===== SCROLLBAR ===== */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: rgba(20, 5, 25, 0.5); }
::-webkit-scrollbar-thumb { background: rgba(255, 20, 147, 0.3); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: rgba(255, 20, 147, 0.5); }

/* ===== RESPONSIVE ===== */
@media (max-width: 768px) {
  .main { flex-direction: column; }
  .side-panel { width: 100%; min-width: auto; max-height: 40vh; border-right: none; border-bottom: 2px solid rgba(255,20,147,0.2); }
  .toggle-panel { display: none; }
  .logo { font-size: 1.1rem; }
}

/* ===== WELCOME TOAST ===== */
.toast {
  position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%);
  background: linear-gradient(135deg, rgba(255,20,147,0.9), rgba(199,21,133,0.9));
  color: #fff; padding: 12px 24px; border-radius: 30px;
  font-size: 0.9rem; z-index: 50;
  box-shadow: 0 4px 25px rgba(255,20,147,0.5);
  animation: toastIn 0.5s ease, toastOut 0.5s ease 4s forwards;
  pointer-events: none;
}
@keyframes toastIn { from { opacity: 0; transform: translateX(-50%) translateY(20px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }
@keyframes toastOut { to { opacity: 0; transform: translateX(-50%) translateY(20px); } }
</style>
</head>
<body>

<!-- Floating Particles -->
<div class="particles" id="particles"></div>

<!-- App -->
<div class="app">

  <!-- Top Bar -->
  <div class="top-bar">
    <div class="logo">üå∏ Groovy Julia Set Explorer ‚ú®</div>
    <div class="top-controls">
      <select id="colorScheme" title="Color Groove">
        <option value="0">ü©∑ Hot Pink Dream</option>
        <option value="1">üç¨ Bubblegum Bliss</option>
        <option value="2">‚ö° Neon Pink Explosion</option>
        <option value="3">üåπ Rose Garden</option>
        <option value="4">üåå Cosmic Pink</option>
        <option value="5">üåÖ Sunset Groove</option>
      </select>
      <button class="btn" id="helpBtn">‚ú® Info</button>
    </div>
  </div>

  <!-- Main -->
  <div class="main">

    <!-- Side Panel -->
    <div class="side-panel" id="sidePanel">

      <div class="section-title">üå∏ Groovy Presets</div>
      <div class="preset-grid" id="presetGrid"></div>

      <div class="section-title">üåÄ Morph the Cosmos</div>
      <div class="morph-section">
        <button class="morph-toggle" id="morphToggle">üåÄ Start Morphing</button>
        <div class="morph-mode-btns">
          <button class="morph-mode-btn active" data-mode="loop">Loop</button>
          <button class="morph-mode-btn" data-mode="random">Random</button>
        </div>
        <div class="slider-group">
          <div class="slider-label"><span>Speed</span></div>
          <input type="range" id="morphSpeed" min="1" max="10" value="5" step="0.5">
          <div class="speed-labels"><span>Chill üêå</span><span>Cosmic üöÄ</span></div>
        </div>
        <div class="morph-status" id="morphStatus"></div>
      </div>

      <div class="section-title">üéõÔ∏è Real Vibes / Imaginary Vibes</div>
      <div class="slider-group">
        <div class="slider-label"><span>Real Vibes (Re)</span><span class="slider-value" id="realVal">-0.750</span></div>
        <input type="range" id="realSlider" min="-2" max="2" value="-0.75" step="0.001">
      </div>
      <div class="slider-group">
        <div class="slider-label"><span>Imaginary Vibes (Im)</span><span class="slider-value" id="imagVal">0.110</span></div>
        <input type="range" id="imagSlider" min="-2" max="2" value="0.11" step="0.001">
      </div>

      <div class="section-title">üî¨ Iteration Depth</div>
      <div class="slider-group">
        <div class="slider-label"><span>Max Iterations</span><span class="slider-value" id="iterVal">200</span></div>
        <input type="range" id="iterSlider" min="50" max="500" value="200" step="10">
      </div>

      <div class="section-title">üëÅÔ∏è View Controls</div>
      <div class="view-btns">
        <button class="btn" id="resetViewBtn">üå∏ Reset View</button>
        <button class="btn" id="saveBtn">üíæ Save Trip</button>
      </div>
    </div>

    <!-- Canvas Area -->
    <div class="canvas-area">
      <div class="canvas-wrapper">
        <canvas id="fractalCanvas" width="700" height="700"></canvas>
      </div>
    </div>

  </div>

  <!-- Bottom Bar -->
  <div class="bottom-bar">
    <span>c = <span class="c-value" id="cDisplay">-0.750 + 0.110i</span></span>
    <span>Zoom: <span id="zoomDisplay">1.00x</span></span>
    <span>Iterations: <span id="iterDisplay">200</span></span>
    <span>FPS: <span id="fpsDisplay">--</span></span>
  </div>

</div>

<!-- Help Modal -->
<div class="modal-overlay" id="helpModal">
  <div class="modal">
    <h2>üå∏ Welcome to the Groovy Julia Set Explorer! ‚ú®</h2>
    <p>These trippy patterns come from one simple formula repeated infinitely: <strong>z = z&sup2; + c</strong>. Each pixel asks: does this point escape to infinity or stay trapped forever? The colors show how fast it escapes.</p>
    <p>Click a <strong>groovy preset</strong> to explore famous fractals. Hit <strong>"Morph"</strong> to watch them flow between dimensions. Zoom in - the patterns are infinite! Every zoom reveals new complexity.</p>
    <p>It's all far out, baby! ‚òÆÔ∏èüíï</p>
    <h2>‚å®Ô∏è Keyboard Shortcuts</h2>
    <div class="shortcuts">
      <kbd>Space</kbd><span>Toggle morphing</span>
      <kbd>Arrow keys</kbd><span>Pan view</span>
      <kbd>+ / -</kbd><span>Zoom in / out</span>
      <kbd>R</kbd><span>Reset view</span>
      <kbd>S</kbd><span>Save image</span>
      <kbd>1-8</kbd><span>Jump to preset</span>
    </div>
    <button class="modal-close" id="closeModal">‚ú® Far Out! ‚ú®</button>
  </div>
</div>

<!-- Welcome Toast -->
<div class="toast" id="welcomeToast">Click a groovy preset or start morphing! ‚ú®</div>

<script>
// ===== PRESETS =====
const PRESETS = [
  { name: "Dendrite Dream", icon: "üåø", re: 0.0, im: 1.0, desc: "Branching like cosmic trees" },
  { name: "Spiral Galaxy", icon: "üåÄ", re: -0.75, im: 0.11, desc: "Swirling through infinity" },
  { name: "Douady Rabbit", icon: "üê∞", re: -0.123, im: 0.745, desc: "Hopping through the complex plane" },
  { name: "San Marco", icon: "‚≠ê", re: -0.75, im: 0.0, desc: "Classic fractal beauty" },
  { name: "Dragon Curve", icon: "üêâ", re: -0.8, im: 0.156, desc: "Fire-breathing fractals" },
  { name: "Siegel Disk", icon: "üí´", re: -0.391, im: -0.587, desc: "Spiraling into the void" },
  { name: "Peacock Feather", icon: "ü¶ö", re: 0.285, im: 0.01, desc: "Iridescent fractal plumage" },
  { name: "Cosmic Dust", icon: "‚ú®", re: -0.4, im: 0.6, desc: "Stardust in the complex plane" },
];

// ===== COLOR SCHEMES =====
const COLOR_SCHEMES = [
  { name: "Hot Pink Dream", colors: [[255,20,147],[255,0,255],[139,0,139],[0,0,0]] },
  { name: "Bubblegum Bliss", colors: [[255,182,193],[255,105,180],[221,160,221],[48,25,52]] },
  { name: "Neon Pink Explosion", colors: [[255,16,240],[255,0,255],[255,20,147],[0,0,0]] },
  { name: "Rose Garden", colors: [[255,102,204],[196,129,137],[224,176,255],[74,25,66]] },
  { name: "Cosmic Pink", colors: [[255,20,147],[230,230,250],[0,255,255],[10,0,21]] },
  { name: "Sunset Groove", colors: [[255,127,80],[255,218,185],[255,215,0],[45,27,61]] },
];

// ===== STATE =====
let cReal = -0.75, cImag = 0.11;
let centerX = 0, centerY = 0, zoom = 1;
let maxIter = 200;
let colorSchemeIdx = 0;
let selectedPreset = 1;
let isMorphing = false;
let morphMode = 'loop';
let morphSpeed = 5;
let morphIdx = 0;
let morphProgress = 0;
let isPanning = false, panStartX, panStartY, panCX, panCY;

// Performance
let lastFrameTime = 0, frameCount = 0, fps = 0, fpsTimer = 0;
let needsRender = true;
let renderTimeout = null;

// ===== DOM REFS =====
const canvas = document.getElementById('fractalCanvas');
const ctx = canvas.getContext('2d');
const realSlider = document.getElementById('realSlider');
const imagSlider = document.getElementById('imagSlider');
const iterSlider = document.getElementById('iterSlider');
const realVal = document.getElementById('realVal');
const imagVal = document.getElementById('imagVal');
const iterVal = document.getElementById('iterVal');
const cDisplay = document.getElementById('cDisplay');
const zoomDisplay = document.getElementById('zoomDisplay');
const iterDisplay = document.getElementById('iterDisplay');
const fpsDisplay = document.getElementById('fpsDisplay');
const morphToggle = document.getElementById('morphToggle');
const morphStatus = document.getElementById('morphStatus');
const colorSelect = document.getElementById('colorScheme');

// ===== IMAGE DATA =====
let imageData = ctx.createImageData(canvas.width, canvas.height);

// ===== INIT PRESETS =====
const presetGrid = document.getElementById('presetGrid');
PRESETS.forEach((p, i) => {
  const btn = document.createElement('button');
  btn.className = 'preset-btn' + (i === selectedPreset ? ' selected' : '');
  btn.innerHTML = `${p.icon}<br>${p.name}`;
  btn.title = p.desc;
  btn.addEventListener('click', () => selectPreset(i));
  presetGrid.appendChild(btn);
});

// ===== PARTICLES =====
function createParticles() {
  const container = document.getElementById('particles');
  const emojis = ['‚ú®', 'üå∏', '‚≠ê', 'üí´', 'üå∫', 'üíï', '‚òÆÔ∏è', 'üåô'];
  for (let i = 0; i < 25; i++) {
    const p = document.createElement('div');
    p.className = 'particle';
    p.textContent = emojis[Math.floor(Math.random() * emojis.length)];
    p.style.left = Math.random() * 100 + '%';
    p.style.animationDelay = Math.random() * 12 + 's';
    p.style.animationDuration = (8 + Math.random() * 8) + 's';
    p.style.fontSize = (0.8 + Math.random() * 1.2) + 'rem';
    container.appendChild(p);
  }
}
createParticles();

// ===== COLOR MAPPING =====
function getColor(iter, maxIter) {
  if (iter >= maxIter) {
    const s = COLOR_SCHEMES[colorSchemeIdx].colors[3];
    return [s[0], s[1], s[2]];
  }
  const scheme = COLOR_SCHEMES[colorSchemeIdx].colors;
  const t = iter / maxIter;

  // Smooth coloring with multiple bands
  const wave = t * 4;
  let r, g, b;
  if (wave < 1) {
    const f = wave;
    r = lerp(scheme[0][0], scheme[1][0], f);
    g = lerp(scheme[0][1], scheme[1][1], f);
    b = lerp(scheme[0][2], scheme[1][2], f);
  } else if (wave < 2) {
    const f = wave - 1;
    r = lerp(scheme[1][0], scheme[2][0], f);
    g = lerp(scheme[1][1], scheme[2][1], f);
    b = lerp(scheme[1][2], scheme[2][2], f);
  } else if (wave < 3) {
    const f = wave - 2;
    r = lerp(scheme[2][0], scheme[1][0], f);
    g = lerp(scheme[2][1], scheme[1][1], f);
    b = lerp(scheme[2][2], scheme[1][2], f);
  } else {
    const f = wave - 3;
    r = lerp(scheme[1][0], scheme[0][0], f);
    g = lerp(scheme[1][1], scheme[0][1], f);
    b = lerp(scheme[1][2], scheme[0][2], f);
  }
  return [Math.floor(r), Math.floor(g), Math.floor(b)];
}

function lerp(a, b, t) { return a + (b - a) * t; }

// ===== FRACTAL RENDERING =====
function renderFractal() {
  const w = canvas.width, h = canvas.height;
  const data = imageData.data;
  const scale = 4.0 / (zoom * w);
  const ox = centerX - (w / 2) * scale;
  const oy = centerY - (h / 2) * scale;

  for (let py = 0; py < h; py++) {
    for (let px = 0; px < w; px++) {
      let zr = ox + px * scale;
      let zi = oy + py * scale;
      let iter = 0;

      while (iter < maxIter && zr * zr + zi * zi <= 4) {
        const tr = zr * zr - zi * zi + cReal;
        zi = 2 * zr * zi + cImag;
        zr = tr;
        iter++;
      }

      // Smooth coloring
      let smoothIter = iter;
      if (iter < maxIter) {
        const log_zn = Math.log(zr * zr + zi * zi) / 2;
        const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
        smoothIter = iter + 1 - nu;
        if (isNaN(smoothIter) || smoothIter < 0) smoothIter = 0;
      }

      const [r, g, b] = getColor(smoothIter, maxIter);
      const idx = (py * w + px) * 4;
      data[idx] = r;
      data[idx + 1] = g;
      data[idx + 2] = b;
      data[idx + 3] = 255;
    }
  }

  ctx.putImageData(imageData, 0, 0);
  needsRender = false;
}

// ===== THROTTLED RENDER =====
function requestRender() {
  needsRender = true;
}

// ===== SELECT PRESET =====
function selectPreset(idx, animate = true) {
  selectedPreset = idx;
  const p = PRESETS[idx];

  // Update selected button
  document.querySelectorAll('.preset-btn').forEach((b, i) => {
    b.classList.toggle('selected', i === idx);
  });

  if (animate && !isMorphing) {
    animateTo(p.re, p.im);
  } else {
    cReal = p.re;
    cImag = p.im;
    updateSliders();
    requestRender();
  }
}

function animateTo(targetRe, targetIm, duration = 1200) {
  const startRe = cReal, startIm = cImag;
  const startTime = performance.now();

  function step(now) {
    const elapsed = now - startTime;
    let t = Math.min(elapsed / duration, 1);
    // Ease in-out
    t = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

    cReal = lerp(startRe, targetRe, t);
    cImag = lerp(startIm, targetIm, t);
    updateSliders();
    requestRender();

    if (t < 1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

// ===== UPDATE SLIDERS =====
function updateSliders() {
  realSlider.value = cReal;
  imagSlider.value = cImag;
  realVal.textContent = cReal.toFixed(3);
  imagVal.textContent = cImag.toFixed(3);
  updateCDisplay();
}

function updateCDisplay() {
  const sign = cImag >= 0 ? '+' : '-';
  cDisplay.textContent = `${cReal.toFixed(3)} ${sign} ${Math.abs(cImag).toFixed(3)}i`;
}

// ===== MORPHING =====
function startMorphing() {
  isMorphing = true;
  morphToggle.textContent = "üåÄ Stop Morphing";
  morphToggle.classList.add('active');
  morphProgress = 0;

  if (morphMode === 'loop') {
    morphIdx = selectedPreset;
  } else {
    morphIdx = Math.floor(Math.random() * PRESETS.length);
  }
}

function stopMorphing() {
  isMorphing = false;
  morphToggle.textContent = "üåÄ Start Morphing";
  morphToggle.classList.remove('active');
  morphStatus.textContent = '';
}

function updateMorph(dt) {
  if (!isMorphing) return;

  const speedFactor = morphSpeed / 5;
  const transitionDuration = 4000 / speedFactor; // ms per transition
  morphProgress += dt;

  const currentIdx = morphIdx;
  let nextIdx;
  if (morphMode === 'loop') {
    nextIdx = (currentIdx + 1) % PRESETS.length;
  } else {
    // Random - pick a different one
    nextIdx = currentIdx;
    while (nextIdx === currentIdx) {
      nextIdx = Math.floor(Math.random() * PRESETS.length);
    }
  }

  let t = morphProgress / transitionDuration;
  if (t >= 1) {
    t = 1;
    morphIdx = nextIdx;
    morphProgress = 0;
    // Update selected preset highlight
    document.querySelectorAll('.preset-btn').forEach((b, i) => {
      b.classList.toggle('selected', i === morphIdx);
    });
  }

  // Ease in-out
  const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

  const from = PRESETS[currentIdx];
  const to = PRESETS[nextIdx];
  cReal = lerp(from.re, to.re, eased);
  cImag = lerp(from.im, to.im, eased);
  updateSliders();
  requestRender();

  morphStatus.textContent = `${from.icon} ${from.name} ‚Üí ${to.icon} ${to.name}`;
}

// ===== ZOOM & PAN =====
canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  const factor = e.deltaY > 0 ? 0.85 : 1.18;
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) / rect.width;
  const my = (e.clientY - rect.top) / rect.height;

  const scale = 4.0 / (zoom * canvas.width);
  const wx = centerX + (mx - 0.5) * canvas.width * scale;
  const wy = centerY + (my - 0.5) * canvas.height * scale;

  zoom *= factor;
  centerX = wx - (mx - 0.5) * canvas.width * (4.0 / (zoom * canvas.width));
  centerY = wy - (my - 0.5) * canvas.height * (4.0 / (zoom * canvas.height));

  zoomDisplay.textContent = zoom.toFixed(2) + 'x';
  requestRender();
}, { passive: false });

canvas.addEventListener('mousedown', (e) => {
  isPanning = true;
  panStartX = e.clientX; panStartY = e.clientY;
  panCX = centerX; panCY = centerY;
});
window.addEventListener('mousemove', (e) => {
  if (!isPanning) return;
  const scale = 4.0 / (zoom * canvas.width);
  centerX = panCX - (e.clientX - panStartX) * scale;
  centerY = panCY - (e.clientY - panStartY) * scale;
  requestRender();
});
window.addEventListener('mouseup', () => { isPanning = false; });

canvas.addEventListener('dblclick', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) / rect.width;
  const my = (e.clientY - rect.top) / rect.height;
  const scale = 4.0 / (zoom * canvas.width);
  centerX = centerX + (mx - 0.5) * canvas.width * scale;
  centerY = centerY + (my - 0.5) * canvas.height * scale;
  zoom *= 1.5;
  zoomDisplay.textContent = zoom.toFixed(2) + 'x';
  requestRender();
});

// ===== SLIDER EVENTS =====
realSlider.addEventListener('input', () => {
  if (isMorphing) stopMorphing();
  cReal = parseFloat(realSlider.value);
  realVal.textContent = cReal.toFixed(3);
  updateCDisplay();
  requestRender();
});
imagSlider.addEventListener('input', () => {
  if (isMorphing) stopMorphing();
  cImag = parseFloat(imagSlider.value);
  imagVal.textContent = cImag.toFixed(3);
  updateCDisplay();
  requestRender();
});
iterSlider.addEventListener('input', () => {
  maxIter = parseInt(iterSlider.value);
  iterVal.textContent = maxIter;
  iterDisplay.textContent = maxIter;
  requestRender();
});

// ===== MORPH CONTROLS =====
morphToggle.addEventListener('click', () => {
  isMorphing ? stopMorphing() : startMorphing();
});

document.querySelectorAll('.morph-mode-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.morph-mode-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    morphMode = btn.dataset.mode;
  });
});

document.getElementById('morphSpeed').addEventListener('input', (e) => {
  morphSpeed = parseFloat(e.target.value);
});

// ===== COLOR SCHEME =====
colorSelect.addEventListener('change', () => {
  colorSchemeIdx = parseInt(colorSelect.value);
  requestRender();
});

// ===== VIEW CONTROLS =====
document.getElementById('resetViewBtn').addEventListener('click', resetView);
document.getElementById('saveBtn').addEventListener('click', saveImage);

function resetView() {
  centerX = 0; centerY = 0; zoom = 1;
  zoomDisplay.textContent = '1.00x';
  requestRender();
}

function saveImage() {
  const link = document.createElement('a');
  const sign = cImag >= 0 ? '+' : '-';
  link.download = `julia_c${cReal.toFixed(3)}${sign}${Math.abs(cImag).toFixed(3)}i_${Date.now()}.png`;
  link.href = canvas.toDataURL('image/png');
  link.click();
}

// ===== HELP MODAL =====
document.getElementById('helpBtn').addEventListener('click', () => {
  document.getElementById('helpModal').classList.add('visible');
});
document.getElementById('closeModal').addEventListener('click', () => {
  document.getElementById('helpModal').classList.remove('visible');
});
document.getElementById('helpModal').addEventListener('click', (e) => {
  if (e.target === e.currentTarget) document.getElementById('helpModal').classList.remove('visible');
});

// ===== KEYBOARD SHORTCUTS =====
document.addEventListener('keydown', (e) => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

  const panAmount = 0.1 / zoom;
  switch (e.key) {
    case ' ':
      e.preventDefault();
      isMorphing ? stopMorphing() : startMorphing();
      break;
    case 'ArrowLeft': centerX -= panAmount * 4; requestRender(); break;
    case 'ArrowRight': centerX += panAmount * 4; requestRender(); break;
    case 'ArrowUp': centerY -= panAmount * 4; requestRender(); break;
    case 'ArrowDown': centerY += panAmount * 4; requestRender(); break;
    case '=': case '+': zoom *= 1.3; zoomDisplay.textContent = zoom.toFixed(2) + 'x'; requestRender(); break;
    case '-': zoom *= 0.77; zoomDisplay.textContent = zoom.toFixed(2) + 'x'; requestRender(); break;
    case 'r': case 'R': resetView(); break;
    case 's': case 'S': saveImage(); break;
    default:
      const num = parseInt(e.key);
      if (num >= 1 && num <= 8) selectPreset(num - 1);
  }
});

// ===== MAIN LOOP =====
let lastTime = performance.now();
function mainLoop(now) {
  const dt = now - lastTime;
  lastTime = now;

  // FPS counter
  frameCount++;
  fpsTimer += dt;
  if (fpsTimer >= 1000) {
    fps = Math.round(frameCount * 1000 / fpsTimer);
    fpsDisplay.textContent = fps;
    frameCount = 0;
    fpsTimer = 0;
  }

  // Morphing
  if (isMorphing) {
    updateMorph(dt);
  }

  // Render
  if (needsRender) {
    renderFractal();
  }

  requestAnimationFrame(mainLoop);
}

// ===== RESPONSIVE CANVAS =====
function resizeCanvas() {
  const area = document.querySelector('.canvas-area');
  const size = Math.min(area.clientWidth - 40, area.clientHeight - 40, 800);
  const s = Math.max(300, size);
  canvas.width = s;
  canvas.height = s;
  imageData = ctx.createImageData(s, s);
  requestRender();
}
window.addEventListener('resize', resizeCanvas);

// ===== START =====
resizeCanvas();
updateSliders();
requestAnimationFrame(mainLoop);

// Remove toast after animation
setTimeout(() => {
  const toast = document.getElementById('welcomeToast');
  if (toast) toast.remove();
}, 5000);
</script>

</body>
</html>
